pragma language_version 0.16;

import CompactStandardLibrary;

// Mapping from token ID to owner public key
export ledger tokenOwner: Map<Uint<64>, ZswapCoinPublicKey>;

// Mapping from token ID to approved public key (for single-token approval)
export ledger tokenApprovals: Map<Uint<64>, ZswapCoinPublicKey>;

// Mapping from owner to number of owned tokens (using a Counter type for safe increment/decrement)
export ledger ownedTokensCount: Map<ZswapCoinPublicKey, Counter>;

// Mapping from owner to operator approvals (owner -> operator -> bool)
// Using a flat structure: concatenate owner+operator bytes as composite key
export ledger operatorApprovals: Map<Bytes<64>, Boolean>;

// Counter for the next token ID to be minted
export ledger currentTokenId: Counter;

// Returns the number of tokens owned by a given public key
export circuit balanceOf(owner: ZswapCoinPublicKey): Uint<64> {
  assert(owner != default<ZswapCoinPublicKey>, "Owner cannot be empty.");
  if (ownedTokensCount.member(disclose(owner))) {
    return ownedTokensCount.lookup(disclose(owner));
  } else {
    return 0;
  }
}

// Returns the owner of a given token ID
export circuit ownerOf(tokenId: Uint<64>): ZswapCoinPublicKey {
  assert(tokenId != default<Uint<64>>, "Token ID cannot be empty.");
  assert(tokenExists(tokenId), "Token does not exist.");
  return tokenOwner.lookup(disclose(tokenId));
}

// Approves another public key to transfer the specified token ID
export circuit approve(to: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  const senderPublicKey = ownPublicKey();
  assert(to != default<ZswapCoinPublicKey>, "Approved address cannot be empty.");

  const owner = disclose(ownerOf(tokenId));
  assert(to != owner, "Cannot approve yourself.");

  // The caller must be the owner or an approved operator
  assert(senderPublicKey == owner || isApprovedForAll(owner, senderPublicKey), "Not authorized.");
  
  tokenApprovals.insert(disclose(tokenId), disclose(to));
}

// Returns the approved public key for a given token ID
export circuit getApproved(tokenId: Uint<64>): ZswapCoinPublicKey {
  assert(tokenId != default<Uint<64>>, "Token ID cannot be empty.");
  assert(tokenExists(tokenId), "Token does not exist.");

  return tokenApprovals.lookup(disclose(tokenId));
}

// Sets or unsets approval for an operator to manage all of the caller's tokens
export circuit setApprovalForAll(operator: ZswapCoinPublicKey, approved: Boolean): [] {
  const senderPublicKey = ownPublicKey();
  assert(operator != default<ZswapCoinPublicKey>, "Operator cannot be empty.");
  assert(operator != senderPublicKey, "Cannot set yourself as operator.");

  // Create a composite key by combining owner and operator
  const compositeKey = createCompositeKey(senderPublicKey, disclose(operator));
  
  // Set or unset approval for the operator
  operatorApprovals.insert(disclose(compositeKey), disclose(approved));
}


// Checks if an operator is approved to manage all tokens of a given owner
export circuit isApprovedForAll(owner: ZswapCoinPublicKey, operator: ZswapCoinPublicKey): Boolean {
  // Create a composite key by combining owner and operator
  const compositeKey = createCompositeKey(disclose(owner), disclose(operator));
  
  // Check if the approval exists and is true
  if (!operatorApprovals.member(disclose(compositeKey))) {
    return false;
  }
  
  // Return the approval status
  return operatorApprovals.lookup(disclose(compositeKey));
}

// Transfers ownership of a given token ID from one public key to another
export circuit transferFrom(from: ZswapCoinPublicKey, to: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  const senderPublicKey = ownPublicKey();
  assert(tokenId != default<Uint<64>>, "Token ID cannot be empty.");
  assert(isApprovedOrOwner(senderPublicKey, tokenId), "Not authorized to transfer.");

  // Clear approval for this token
  clearApproval(disclose(from), disclose(tokenId));
  
  // Remove token from the current owner
  removeTokenFrom(disclose(from), disclose(tokenId));
  
  // Add token to the new owner
  addTokenTo(disclose(to), disclose(tokenId));
}

// Mints a new token with the specified token ID to the given public key
export circuit mint(to: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  assert(to != default<ZswapCoinPublicKey>, "Recipient cannot be empty.");
  addTokenTo(disclose(to), disclose(tokenId));
}

// Burns (destroys) a specific token. No privileges required.
export circuit burn(owner: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  clearApproval(disclose(owner), disclose(tokenId));
  removeTokenFrom(disclose(owner), disclose(tokenId));
}

// =====================
// Internal helper functions
// =====================
export circuit createCompositeKey(owner: ZswapCoinPublicKey, operator: ZswapCoinPublicKey): Bytes<64> {
  var result: Vector<64, Field> = default<Vector<64, Field>>;
  for (const i of 0..32) {
    result[i] = owner.bytes[i];
    result[i + 32] = operator.bytes[i];
  }
  return result as Bytes<64>;
}

// Returns true if a token exists for the given token ID
circuit tokenExists(tokenId: Uint<64>): Boolean {
  return tokenOwner.member(disclose(tokenId));
}

// Returns true if the spender is the owner, approved, or an operator for the token
circuit isApprovedOrOwner(spender: ZswapCoinPublicKey, tokenId: Uint<64>): Boolean {
  const owner = disclose(ownerOf(tokenId));
  
  // Check if spender is the owner
  if (spender == owner) {
    return true;
  }
  
  // Check if spender is specifically approved for this token
  if (tokenApprovals.member(disclose(tokenId)) && spender == tokenApprovals.lookup(disclose(tokenId))) {
    return true;
  }
  
  // Check if spender is an approved operator for all tokens
  return isApprovedForAll(owner, spender);
}

// Adds a token to a public key, updating ownership and balance
circuit addTokenTo(to: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  assert(!tokenExists(tokenId), "Token already exists.");
  assert(to != default<ZswapCoinPublicKey>, "Recipient cannot be empty.");

  tokenOwner.insert(disclose(tokenId), disclose(to));
  // Initialize the counter if it doesn't exist
  if (!ownedTokensCount.member(disclose(to))) {
    ownedTokensCount.insert(disclose(to), default<Counter>);
  }
  // Increment the owner's token count
  ownedTokensCount.lookup(disclose(to)).increment(1);
}

// Removes a token from a public key, updating ownership and balance
circuit removeTokenFrom(from: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  assert(from != default<ZswapCoinPublicKey>, "Sender cannot be empty.");
  assert(from == disclose(ownerOf(tokenId)), "Public key is not the owner.");
  
  // Decrement the owner's token count
  ownedTokensCount.lookup(disclose(from)).decrement(1);
  // Remove the token from the owner
  tokenOwner.remove(disclose(tokenId));
}

// Clears approval for a token, if any
circuit clearApproval(owner: ZswapCoinPublicKey, tokenId: Uint<64>): [] {
  assert(owner == disclose(ownerOf(tokenId)), "Public key is not the owner.");
  if (disclose(ownerOf(tokenId)) != default<ZswapCoinPublicKey>) {
    tokenApprovals.remove(disclose(tokenId));
  }
}
